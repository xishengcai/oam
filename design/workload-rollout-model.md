# Workload Rollout Model

* Owner: Jianbo Sun (@wonderflow)
* Reviewers: Crossplane Maintainers
* Status: Approved

## Background

Currently, oam-k8s-runtime has component versioning mechanism, and we already support one kind of rollout model in it.
You can refer to [the blue-green workflow](./one-pager-component-mutable-and-versioning.md#example-a-blue-green-workflow)
to understand it better. But that's not cover all of cases.

In kubernetes ecosystem, we usually have two categories of rollout model.

1. Workload can rollout by itself: [StatefulSet](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/) is a typical
example in this category. When there's a version upgrade, statefulset will directly upgrade pod one by one and allow us to control by the field `partition`.
2. Workload can't rollout by itself: [ReplicaSet](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/) is a typical example in this model.
Replica itself don't have rollout feature itself, by we can use it as under layer and build rollout feature by creating two or more replicasets like [Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/).

OAM component versioning mechanism has good support for the second category, we regard the workload itself can't rollout, and let
rollout trait to do it. In this case, if we have a rollout trait which has `revisionEnaled` to be true, oam-runtime will
create new workload instance with the name to be revisionName. **The revision information passed from oam-runtime to rollout trait from workload name**.
With the revision information, `traffic` trait can route different percent of traffic by specified revisionName.

For the first category, oam-runtime directly update the workload without passing any revision information.
In this case, we also need a clearly defined way to integrate this kind workload with traits like `traffic` trait.


## Goals

Our goal is to make sure all workload rollout model described in background can integrate with traits.


## Proposal

The overall idea is we recommend that those rollout-by-self workloads produce a revision label in the pod template it generate.
In this case, traits that handle traffic-related operations can use this label.  

Let's use StatefulSet as an example and go through the whole workflow.

Firstly, we create a statefulset like below:

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: frontend
spec:
  selector:
    matchLabels:
      app: nginx
  serviceName: "nginx"
  replica: 3
  template:
    metadata:
      labels:
        app: nginx
        oam-revision: frontend-c8bb659c5
    spec:
      containers:
      - name: nginx
        image: k8s.gcr.io/nginx-slim:0.8
        ports:
        - containerPort: 80
          name: web
```

It will create three pods:

```
$ kubectl get pods
NAME         READY   STATUS              RESTARTS   AGE
frontend-0   1/1     Running             0          62s
frontend-1   1/1     Running             0          29s
frontend-2   0/1     ContainerCreating   0          2s
```

The statefulset controller generates a label called `controller-revision-hash` which will contain revision info in it and attach it to each pod.

```yaml
$ kubectl get pods -o yaml
apiVersion: v1
items:
- apiVersion: v1
  kind: Pod
  metadata:
    labels:
      app: nginx
      controller-revision-hash: frontend-8d6c8c46f
      statefulset.kubernetes.io/pod-name: frontend-0
    name: frontend-0
    namespace: default
...
- apiVersion: v1
  kind: Pod
  metadata:
    labels:
      app: nginx
      controller-revision-hash: frontend-8d6c8c46f
      statefulset.kubernetes.io/pod-name: frontend-1
    name: frontend-1
    namespace: default
...
- apiVersion: v1
  kind: Pod
  metadata:
    labels:
      app: nginx
      controller-revision-hash: frontend-8d6c8c46f
      statefulset.kubernetes.io/pod-name: frontend-2
    name: frontend-2
    namespace: default
...
```

If we change any field in `spec.template`, a new revision label will be generated by the statefulset controller. We can use `partition`
field to control the percentage of new version replicas.  

For example, if we update the image tag in the statefulset CR:

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: frontend
spec:
  selector:
    matchLabels:
      app: nginx
  serviceName: "nginx"
  replica: 3
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: k8s.gcr.io/nginx-slim:0.9
        ports:
        - containerPort: 80
          name: web
  updateStrategy:
    partition: 2
    type: RollingUpdate
```

One new pod with a new label will be created while two existing pods don't change

```yaml
$ kubectl get pods -o yaml
apiVersion: v1
items:
- apiVersion: v1
  kind: Pod
  metadata:
    labels:
      app: nginx
      controller-revision-hash: frontend-9xs43xs1x
      statefulset.kubernetes.io/pod-name: frontend-0
    name: frontend-0
    namespace: default
...
- apiVersion: v1
  kind: Pod
  metadata:
    labels:
      app: nginx
      controller-revision-hash: frontend-8d6c8c46f
      statefulset.kubernetes.io/pod-name: frontend-1
    name: frontend-1
    namespace: default
...
- apiVersion: v1
  kind: Pod
  metadata:
    labels:
      app: nginx
      controller-revision-hash: frontend-8d6c8c46f
      statefulset.kubernetes.io/pod-name: frontend-2
    name: frontend-2
    namespace: default
...
```

Traits that handles traffic should utilize the pod label.

For example, traffic traits can specify the label name and detect whether different labels exist.

```yaml
apiVersion: extend.oam.dev/v1alpha2
kind: Traffic
spec:
  revisionLabel: "controller-revision-hash"
``` 
 
If different labels are detected, Traffic Trait could create two service/ingress pointing to different revision labels and
finally route different percent of traffic to old and new workloads.

## Affect to current spec

Nothing need to change, just propose a standard way Workload and trait should follow.  
